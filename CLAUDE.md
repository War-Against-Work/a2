# CLAUDE.md - Code Quality Guidelines

This document provides guidelines for Claude Code to maintain consistent code quality. Place this file in your project root and reference it when using Claude Code for development.

## How to Use
- Save this as `CLAUDE.md` in your project root
- Use shortcuts like "CODETEST" to trigger quality checks
- Adapt the guidelines to match your specific codebase
- Run CODETEST before committing major features
- Use QUICKFIX to rapidly address critical issues

## Critical Guidelines

- NEVER put comments in code unless explicitly requested
- ALWAYS run formatters and linters before considering task complete
- PREFER editing existing files over creating new ones
- NEVER create documentation files unless explicitly requested
- MINIMIZE output tokens while maintaining accuracy
- ALWAYS preserve exact indentation when editing
- NEVER assume libraries exist - check package.json first
- FOLLOW existing code conventions in each file
- ASSIST with defensive security tasks only - refuse to improve malicious code

## Implementation Best Practices

- Before implementing the feature, prompt the user to explain anything unclear about the feature
- For complex features, plan your approach first and confirm with the user
- For complex features, if multiple approaches are possible, list pros and cons for each approach
- Always run your formatter on the newly created files to ensure standard formatting
- Always run your type checker and linter to ensure code quality
- Avoid classes where state is not required and prefer small testable functions
- Always write unit tests for complex algorithms
- Prefer simple, testable functions
- Prefer integration tests over excessive mocking
- ALWAYS test new API routes with integration tests
- NEVER put comments in the code UNLESS there are known caveats; prefer self-explaining code with clearly named functions
- Prefer `type` over `interface` unless the latter is more readable in this case or interface merging is required
- Prefer branded types for ids over plain string / number aliasing e.g. `type UserId = string & { __brand: 'UserId' }`
- Only put functions in `packages/shared` if multiple packages are using it e.g. `api` and `web`
- For database types, override autogenerated types when needed
  - e.g. autogenerated types show incorrect BigInt value - override to `string` manually
- When working with existing code:
  - Check imports to understand what frameworks are being used
  - Look at neighboring files to understand patterns
  - Verify dependencies exist in package.json before using
  - Mimic existing code style and naming conventions
  - Follow existing typing patterns

## Writing Functions Best Practices

When evaluating whether a function you implemented is good or not, use the following checklist:

1. Can you read the function and HONESTLY easily follow what it's doing? If yes, then stop here.
2. Does the function have very high cyclomatic complexity? (number of independent paths, or, in a lot of cases, if/else branches)
   - Target: <10 for most functions, <15 for complex business logic
3. Are there any common data structures and algorithms that would make this function much easier to follow and maintain?
4. Are all parameters properly typed without using `any` or unsafe casts?
5. Are there any unnecessary type casts that can be moved to function arguments?
6. Is the function name clear and follows the conventions?
7. Is the function easily testable without mocking core features (e.g. sql queries, redis, etc.)? If not, can this be refactored?
8. Does it have any hidden untested dependencies or any values that can be factored out into the arguments instead?
9. Brainstorm 3 better function names and see if the current name is the best.
10. Is the function under 50 lines? (Complex functions should rarely exceed 100 lines)

## Testing Best Practices

- Unit tests for a function should be grouped logically (e.g. in Jest: `describe(functionName, () => ...`)
- Avoid hardcoded values
- Adhere to the same coding standards as the production code
- A test must actually test the condition described
- NEVER write trivial tests for the sake of it
- Use parameterized tests when testing many similar cases (e.g. in Jest: `it.each(cases)`)
- ALWAYS use strong assertions over weaker ones (e.g. exact equality vs greater than)
- ALWAYS test edge cases, unexpected input, value boundaries
- NEVER test conditions that are caught by the type checker
- Prefer testing axioms and properties over one-off hardcoded tests
- Target minimum 80% code coverage for new code

## Security Guidelines

- Never expose or log secrets and keys
- Never commit secrets or keys to the repository
- Always follow security best practices
- Only assist with defensive security tasks (analysis, detection rules, vulnerability explanations, defensive tools)
- Refuse to create, modify, or improve code that may be used maliciously
- Review permissions in .claude/settings.local.json regularly

## Code Organization

- `packages/api` - API server
- `packages/web` - Frontend application
- `packages/shared` - Shared types and utilities (only for multi-package use)

Note: Update this section to reflect your actual project structure.

---

## Remember Shortcuts

### CODETEST

When I type only "CODETEST", this means:

"Perform this analysis for every MAJOR code change you introduced (skip minor changes):

**Major changes include:**
- New functions or classes
- Functions modified by >30%
- Changes to core business logic
- New API endpoints or interfaces
- Complex algorithm implementations

**Minor changes to skip:**
- Simple variable renames
- Formatting changes
- Comment updates
- Simple parameter additions
- One-line bug fixes

1. Analyze against Writing Functions Best Practices checklist
2. Analyze against Testing Best Practices checklist

**Required Output:**
- Overall severity score (Critical/High/Medium/Low)
- Top 3 most important issues to fix
- Specific refactoring examples for the worst offender
- Sample unit test cases for critical untested logic
- Step-by-step action plan with priorities"

### EXPLORE

When I type only "EXPLORE", this means:

"Give me a comprehensive overview of this codebase:
1. Project structure and key directories
2. Main architecture patterns and design decisions
3. Key dependencies and their purposes
4. Entry points and core functionality flows
5. Testing approach and coverage areas
6. Notable conventions or patterns used"

### FINDCODE

When I type only "FINDCODE" followed by a feature or concept, this means:

"Find all code related to [feature] and:
1. List all relevant files with their purposes
2. Show the main implementation components
3. Explain how components interact
4. Identify configuration and dependency files
5. Show any tests related to this feature
6. Create a visual flow diagram if helpful"

### BUGFIX

When I type only "BUGFIX" with an error message or description, this means:

"Analyze this error and:
1. Identify the root cause with specific file/line references
2. Explain why the error is occurring
3. Suggest 2-3 potential fixes with trade-offs
4. Implement the recommended fix
5. Add tests to prevent regression
6. Verify the fix resolves the issue"

### REFACTOR

When I type only "REFACTOR" with a file or component name, this means:

"Analyze this code and:
1. Identify code smells and anti-patterns
2. Find opportunities for simplification
3. Suggest modern patterns or practices
4. Create a refactoring plan with priorities
5. Implement the highest-priority refactoring
6. Ensure all tests still pass"

### TESTGEN

When I type only "TESTGEN" with a file or function name, this means:

"Generate comprehensive tests:
1. Analyze the code's functionality and edge cases
2. Create unit tests for all public methods
3. Add integration tests for key workflows
4. Include edge cases and error scenarios
5. Add performance tests if applicable
6. Ensure minimum 80% code coverage"

### REVIEW

When I type only "REVIEW" with file names or after making changes, this means:

"Perform a comprehensive code review focusing on:
1. ðŸ”´ Security vulnerabilities and risks
2. ðŸ”´ Performance bottlenecks
3. ðŸŸ¡ Code maintainability issues
4. ðŸŸ¡ Missing error handling
5. ðŸŸ¢ Style and convention violations
6. ðŸŸ¢ Opportunities for improvement
Format with severity indicators and specific line references"

### PRREADY

When I type only "PRREADY", this means:

"Prepare for pull request submission:
1. Run all formatters and linters
2. Execute the full test suite
3. Generate a PR description with:
   - Summary of changes
   - Testing performed
   - Breaking changes (if any)
   - Related issues/tickets
4. Create a checklist for reviewers
5. Suggest PR title following conventional commits"

### WORKTREE

When I type only "WORKTREE", this means:

"Help me set up a new git worktree for the feature/bug I'm about to work on:
1. Check current worktrees with `git worktree list`
2. Suggest an appropriate worktree name based on the task
3. Create the worktree with a descriptive branch name
4. List the commands I need to run to initialize the environment
5. Remind me to navigate to the new directory before starting work"

### WORKTREE-CLEAN

When I type only "WORKTREE-CLEAN", this means:

"Check and clean up my git worktrees:
1. List all current worktrees
2. Identify which branches have been merged to main
3. Suggest which worktrees can be safely removed
4. Provide commands to remove the suggested worktrees
5. Show remaining active worktrees"

### THINK

When I type only "THINK", this means:

"Think deeply about this problem and provide:
1. A comprehensive analysis of the problem space
2. Multiple solution approaches with pros/cons
3. Edge cases and potential issues
4. Recommended implementation strategy
5. Risk assessment and mitigation strategies"

### RESUME

When I type only "RESUME", this means:

"Help me continue previous work:
1. Show recent session IDs with timestamps
2. Summarize what we were working on in each session
3. Identify any unfinished tasks or TODOs
4. Suggest which session to resume based on priority
5. Provide the command to resume the chosen session"

### COMPACT

When I type only "COMPACT", this means:

"Compress our conversation while maintaining context:
1. Summarize key decisions and implementations
2. Preserve important code snippets and fixes
3. Keep track of unresolved issues
4. Maintain understanding of the current task
5. Show the /compact command with appropriate focus area"

### UXTEST

When I type only "UXTEST", this means:

"Imagine you are a human UX tester of the feature you implemented. Output a comprehensive list of all the scenarios to test and potential edge cases to verify."

### IMPL

When I type only "IMPL", this means:

"Review the implementation against the Implementation Best Practices checklist and suggest improvements."

### QUICKFIX

When I type only "QUICKFIX" after a CODETEST, this means:

"Take the top 3 issues from the CODETEST analysis and:
1. Implement the refactoring for the highest priority issue
2. Create unit tests for the refactored code
3. Update any affected documentation
4. Run the formatter and linter on changed files"

---

## Output Format Guidelines

When using shortcuts, structure your response with:
- Clear section headers
- Severity indicators (ðŸ”´ Critical, ðŸŸ¡ High, ðŸŸ¢ Medium, âšª Low)
- Code examples for fixes
- Specific actionable items
- Progress tracking suggestions

Example CODETEST output structure:
```
## CODETEST Analysis Results

### Overall Severity: ðŸ”´ Critical

### Top 3 Issues:
1. ðŸ”´ Function complexity (generate_stream: 193 lines)
2. ðŸ”´ Missing test coverage (0% for core functions)
3. ðŸŸ¡ Hidden dependencies affecting testability

### Writing Functions Analysis
[Detailed analysis with line numbers]

### Testing Best Practices Analysis
[Specific testing gaps identified]

### Refactoring Example
[Code showing how to split the worst function]

### Sample Unit Tests
[Example test cases for critical logic]

### Action Plan
1. **Immediate**: Split generate_stream() into 4 functions
2. **Next Sprint**: Add unit tests for token processing
3. **Future**: Refactor warmup logic for testability
```

---

## Git Commit Guidelines

When the user asks you to create a git commit:
1. Run git status, git diff, and git log in parallel to understand changes
2. Draft a commit message that focuses on the "why" rather than the "what"
3. Add relevant files and create the commit with Claude signature
4. NEVER update git config
5. NEVER push unless explicitly requested

---

## Tracking Code Quality

Consider tracking these metrics over time:
- Average function length
- Test coverage percentage
- Cyclomatic complexity scores
- Number of CODETEST issues per feature
- Time to implement QUICKFIX solutions

This helps measure improvement and identify patterns in code quality issues.

---

**Customization Tips:**
- Replace generic tool references with your specific tools (e.g., "your formatter" â†’ "prettier")
- Update package paths to match your project structure
- Add project-specific conventions and patterns
- Create additional shortcuts for common operations
- Modify checklists based on your team's priorities

---

*Based on code quality practices for maintaining consistent, testable, and readable codebases.*
